\chapter{Implementacja algorytmu}

Dane pochodzące ze skanowania laserowego wysokiej rozdzielczości zajmują bardzo dużo miejsca, przez co
dostęp do nich poprzez Internet wymaga relatywnie długiego czasu (rzędu kilkunastu sekund). Powoduje to,
iż niemożliwym jest zbudowanie systemu który w czasie rzeczywistym przedstawiałby te dane w sposób podobny
do aktualnie dostępnych w Internecie map, jak Google Maps. Aby zaradzić temu problemowi, stworzono dwa algorytmy.
Ich celem było takie przetworzenie danych wejsciowych, aby zmiejszyć ich objętość jednoczesnie nie tracąc zawartych w nich informacji.
W niniejszym rozdziale znajdują się opisy tych algorytmów oraz opis przekształcania ich do formatu shapefile w celu udostępnienia
poprzez GeoServer.

\section{Algorytm Naiwny}

W celu szybkiego otrzymania wyników zdecydowano się na stworzenie prostego (naiwnego) algorytmu. Opierał się on na następujących założeniach:
\begin{itemize}
    \item Dane wejściowe posiadają wysoką rozdzielczość (rzędu kilkudziesieciu punktów na metr)
    \item Punkty znajdujące się blisko siebie (tzn. odległość $d$ ze wzoru \ref{eq:odleglosc_euklidesowa} mniejsza niż stała $C$), są fragmentem tej samej powierzchni
\end{itemize}

\noindent Algorytm ten składa się z następujących faz:
\begin{enumerate}
    \item Wczytywanie danych
    \item Wstępne sortowanie
    \item Przypisywanie do zbiorów
    \item Filtracja zbiorów
    \item Znalezienie otoczenia dla każdego ze zbiorów
\end{enumerate}

\subsection{Wczytywanie danych}

Dzięki wykorzystaniu biblioteki liblas \cite{website:libLASPython}, odczytywanie danych z plików w formacie .las jest niezwykle proste.
Całość ogranicza się do zaimportowania odpowiedniej klasy i wykorzystania prostej pętli for, jak przedstawiono
w algorytmie \ref{lis:wczytanie_danych}

\begin{lstlisting}[frame=L, language=python, caption={Wczytywanie danych}, label={lis:wczytanie_danych}]
from liblas import file

def read_from_file(name):
    points = []
    f = file.File(name)
    for p in f:
        points.append(MyPoint(p.x, p.y, p.z, classification=p.classification))
    f.close()

    return points
\end{lstlisting}

Punkty są przechowywane w pamięci jako obiekty klasy \textit{MyPoint}. W ramach takiego obiektu przechowywane są informacje dotyczące
współrzędnych punktu, przynależności do zbioru oraz klasyfikacji. Obiekt może też określić swoją odległość od innego punktu
za pomocą metody \textit{get\_distance} oraz określić czy dany punkt jest jego sąsiadem przy użyciu metody \textit{is\_neighbour}.

\subsection{Wstępne sortowanie}
\label{chap:wstepne_sortowanie}

Jak stwierdzono we wstępie, jednym z założeń jest, iż punkty znajdujące się blisko siebie są fragmentem tej samej powierzchni.
Oznacza to konieczność porównywania ze sobą punktów w systemie każdy z każdym, aby stwierdzić, które z nich należą do tego samego zbioru.
Jedakże takie podejście oznacza złożoność obliczeniową rzędu $O(N^2)$, która,  przy ilości punktów wynoszącą kilka milionów, jest niedopuszczalna.
Aby przyspieszyć obliczenia, zdecydowano się na wstępne posortowanie punktów, aby możliwe było porównywanie danego punktu tylko z punktami z 
jego najbliższego otoczenia.

Sortowanie polega na umieszczeniu punktów w macierzy $[M x N]$, której wymiary odpowiadają różnicy między największa i najmniejszą wartością
współrzędnych $x, y$ punktu $p$ ze zbioru punktów wejściowych $P$:
\begin{eqnarray}
    M = max(p.x) - min(p.x) \bigvee p \in P \\
    N = max(p.y) - min(p.y) \bigvee p \in P
\end{eqnarray}

\noindent Punkty umieszczane są w odpowiadjącym ich współrzędnym komórkach macierzy (algorytm \ref{lis:sortowanie_punktow}).

\begin{lstlisting}[frame=L, language=python, caption={Sortowanie punktów}, label={lis:sortowanie_punktow}]
sorted_points = [[ [] for _ in range(0, N)] for _ in range(0, M)]

for p in P:
    x = int(math.floor(p.x - xmin))
    y = int(math.floor(p.y - ymin))
    sorted_points[x][y].append(p)

\end{lstlisting}

W uproszczeniu można powiedzieć, iż algorytm ten powoduje nałożenie siatki na chmurę punktów, co zostało zobrazowane na rysunku \ref{fig:sortowanie_punktow}

\begin{figure}[h!]
	\centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/sortowanie_punktow1.png}
    \end{subfigure}%
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/sortowanie_punktow2.png}
    \end{subfigure}%
    \caption{Sortowanie punktów w zbiorze}
    \label{fig:sortowanie_punktow}
\end{figure}

\subsection{Przypisywanie do zbiorów}
W tym etapie następuje podział punktów na podzbiory na podstawie sąsiedztwa. Punkty znajdujące się blisko siebie,
są zaliczane do jednego zbioru i tym samym traktowane jako fragmenty tej samej powierzchni. Dzięki posortowaniu
możliwe jest porównywanie tylko punktów leżących blisko siebie w projekcji dwuwymiarowej (z pominięciem składowej $z$).
Algorytm wygląda następująco:

\begin{lstlisting}[frame=L, language=python, caption={Podział punktów na zbiory w algorytmie naiwnym}, label={lis:podzial_naiwny}]
def find_neighbour(point, neighbour_points, sets):
    if point.point_set is None:
        point.point_set = len(sets)
        sets.append([point])

    for p in neighbour_points:
        if point.is_neighbour(p):
            if p.point_set is None:
                sets[point.point_set].append(p)
                p.point_set = point.point_set
            elif point.point_set != p.point_set:
                union_sets(point.point_set, p.point_set, sets)
\end{lstlisting}

W funkcji przedstawionej na listingu \ref{lis:podzial_naiwny} dokonuje się całe clou algorytmu naiwnego.
W pierwszej części (linie 2-4) aktualnie badany punkt (\textit{point}) tworzy nowy jednoelementowy zbiór,
jeśli nie należy do żadnego.

Następnie punkt ten jest porównywany ze wszystkimi pobliskimi\footnote{pobliskie punkty to takie,
które znajdują się w tej samej lub sąsiedniej komórce macierzy. Patrz \autoref{chap:wstepne_sortowanie}}
punktami. Najpierw sprawdzana jest, czy dwa punkty są sąsiadami tzn. czy leżą na tej samej powierzchni. 
Określa się to poprzez obliczenie odległości $d$ między nimi. Odległość ta jest określana przez metrykę euklidesową:
\begin{equation} \label{eq:odleglosc_euklidesowa_ogolna}
    d(A,B) = \sqrt{\sum\limits_{i=1}^n((x_{iA}-x_{iB})^2)}
\end{equation}

\noindent Gdzie $n$ określa liczbę wymiarów. Dla przypadku trójwymiarowego, równanie \ref{eq:odleglosc_euklidesowa_ogolna} można uprościć do:
\begin{equation} \label{eq:odleglosc_euklidesowa}
    d(A,B) = \sqrt{(x_A - x_B)^2 + (y_A - y_B)^2 + (z_A - z_B)^2}
\end{equation}

Gdzie $x, y, z$ są kolejnymi współrzędymi punktu. Po obliczeniu odległości $d$ na podstawie równania \ref{eq:odleglosc_euklidesowa}
jest sprawdzane, czy jest ona mniejsza niż stała $C$. Jeżeli tak, uznaje się że punkty są sąsiadami. Cały proces został zilustrowany na
rysunku \ref{fig:sprawdzanie_sasiedztwa}

\begin{figure}[h!]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/sasiedztwo_punktow1.png}
        \caption {punkty należą do tego samego zbioru (d < C)}
    \end{subfigure}
    \quad
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/sasiedztwo_punktow2.png}
        \caption {punkty nie należą do tego samego zbioru (d > C)}
    \end{subfigure}%
    \caption{Sprawdzanie sąsiedztwa punktów wobec punktu A}
    \label{fig:sprawdzanie_sasiedztwa}
\end{figure}


Po sprawdzeniu sąsiedztwa, jeżeli drugi z punktów nie należy do żadnego zbioru, przypisuje się go do tego samego zbioru, co badany punkt \textit{point}.
W przeciwnym przypadku (gdy oba punkty należą do różnych zbiorów), zbiory te są łączone przy wykorzystaniu metody \textit{union\_set}.
Metoda ta przepisuje wszystkie punkty z mniejszego zbioru do większego (dbając przy tym o poprawność indeksów).

